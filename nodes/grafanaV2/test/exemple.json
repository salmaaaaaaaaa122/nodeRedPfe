[
  {
    "id": "flow20",
    "label": "üå§Ô∏è Station M√©t√©o Grafana",
    "nodes": [
      {
        "id": "http-in-1",
        "type": "http in",
        "z": "flow20",
        "name": "HTTP R√©ception Donn√©es",
        "url": "/sensor-data",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 100,
        "wires": [["function-1"]]
      },
      {
        "id": "function-1",
        "type": "function",
        "z": "flow20",
        "name": "üìù Parser Donn√©es Capteur",
        "func": "// V√©rifier si les donn√©es sont valides\nif (!msg.payload || typeof msg.payload !== 'object') {\n    node.error('Donn√©es invalides re√ßues', msg);\n    return null;\n}\n\n// Parser les donn√©es du capteur\nconst sensorData = {\n    temperature: parseFloat(msg.payload.temperature) || 20 + Math.random() * 15,\n    humidity: parseFloat(msg.payload.humidity) || 40 + Math.random() * 40,\n    location: msg.payload.location || 'bureau',\n    timestamp: new Date().toISOString()\n};\n\n// Ajouter des m√©tadonn√©es\nmsg.payload = sensorData;\nmsg.topic = 'sensor/weather';\nmsg.timestamp = sensorData.timestamp;\n\n// Log pour debug\nnode.log(`Donn√©es re√ßues: T=${sensorData.temperature}¬∞C, H=${sensorData.humidity}%`);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 100,
        "wires": [["grafana-send-1", "debug-1"]]
      },
      {
        "id": "grafana-send-1",
        "type": "grafana-send",
        "z": "flow20",
        "name": "üìä Envoi Grafana",
        "grafanaUrl": "http://localhost:3000",
        "apiToken": "glsa_xxxxxxxxxxxxxxxx",
        "datasourceName": "influxdb-uid",
        "measurement": "sensor_data",
        "x": 670,
        "y": 100,
        "wires": [["http-response-1"]]
      },
      {
        "id": "http-response-1",
        "type": "http response",
        "z": "flow20",
        "name": "‚úÖ R√©ponse HTTP",
        "statusCode": "200",
        "headers": {},
        "x": 890,
        "y": 100,
        "wires": []
      },
      {
        "id": "debug-1",
        "type": "debug",
        "z": "flow20",
        "name": "üêõ Debug Capteur",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 160,
        "wires": []
      },
      {
        "id": "inject-1",
        "type": "inject",
        "z": "flow20",
        "name": "üß™ Test Donn√©es",
        "props": [
          {
            "p": "payload"
          }
        ],
        "repeat": "600",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"temperature\": 23.5, \"humidity\": 65.2, \"location\": \"salon\"}",
        "payloadType": "json",
        "x": 150,
        "y": 200,
        "wires": [["function-simulate"]]
      },
      {
        "id": "function-simulate",
        "type": "function",
        "z": "flow20",
        "name": "üé≤ Simulateur M√©t√©o",
        "func": "// Simuler des donn√©es m√©t√©o r√©alistes\nconst baseTemp = 22;\nconst baseHumidity = 55;\nconst timeVariation = Math.sin(Date.now() / 3600000) * 5; // Variation sur 1h\nconst randomVariation = (Math.random() - 0.5) * 3;\n\nconst sensorData = {\n    temperature: Math.round((baseTemp + timeVariation + randomVariation) * 10) / 10,\n    humidity: Math.round((baseHumidity + Math.random() * 20 - 10) * 10) / 10,\n    location: ['salon', 'cuisine', 'bureau'][Math.floor(Math.random() * 3)],\n    sensor_id: 'weather_001',\n    battery: Math.round((85 + Math.random() * 15) * 10) / 10\n};\n\nmsg.payload = sensorData;\nmsg.topic = 'sensor/simulated';\n\nnode.log(`Simulation: T=${sensorData.temperature}¬∞C, H=${sensorData.humidity}%`);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 200,
        "wires": [["grafana-send-1", "debug-2"]]
      },
      {
        "id": "debug-2",
        "type": "debug",
        "z": "flow20",
        "name": "üéØ Debug Simulation",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 690,
        "y": 240,
        "wires": []
      },
      {
        "id": "grafana-receive-1",
        "type": "grafana-receive",
        "z": "flow20",
        "name": "üì® Alertes Grafana",
        "port": 1880,
        "path": "/grafana-webhook",
        "x": 170,
        "y": 320,
        "wires": [["function-alert-parser"]]
      },
      {
        "id": "function-alert-parser",
        "type": "function",
        "z": "flow20",
        "name": "üö® Parser Alertes",
        "func": "// Parser les alertes Grafana\nconst payload = msg.payload;\n\nif (!payload || !payload.alerts) {\n    node.warn('Payload d\\'alerte invalide');\n    return null;\n}\n\n// Traiter chaque alerte\nconst processedAlerts = payload.alerts.map(alert => {\n    const alertInfo = {\n        name: alert.labels?.alertname || 'Alerte inconnue',\n        status: alert.status,\n        severity: alert.labels?.severity || 'info',\n        instance: alert.labels?.instance || 'non sp√©cifi√©',\n        summary: alert.annotations?.summary || 'Pas de r√©sum√©',\n        description: alert.annotations?.description || '',\n        value: alert.annotations?.value || 'N/A',\n        startsAt: alert.startsAt,\n        endsAt: alert.endsAt,\n        generatorURL: alert.generatorURL\n    };\n    \n    return alertInfo;\n});\n\n// Cr√©er le message de sortie\nmsg.alerts = processedAlerts;\nmsg.alertCount = processedAlerts.length;\nmsg.firingAlerts = processedAlerts.filter(a => a.status === 'firing').length;\nmsg.resolvedAlerts = processedAlerts.filter(a => a.status === 'resolved').length;\n\n// Log des alertes importantes\nprocessedAlerts.forEach(alert => {\n    if (alert.status === 'firing') {\n        node.warn(`üî• ALERTE: ${alert.name} - ${alert.summary}`);\n    } else {\n        node.log(`‚úÖ R√âSOLUE: ${alert.name}`);\n    }\n});\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 320,
        "wires": [["switch-alert-type"]]
      },
      {
        "id": "switch-alert-type",
        "type": "switch",
        "z": "flow20",
        "name": "üîÄ Tri par S√©v√©rit√©",
        "property": "alerts[0].severity",
        "propertyType": "msg",
        "rules": [
          {
            "t": "eq",
            "v": "critical",
            "vt": "str"
          },
          {
            "t": "eq",
            "v": "warning",
            "vt": "str"
          },
          {
            "t": "else"
          }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 3,
        "x": 650,
        "y": 320,
        "wires": [
          ["function-critical"],
          ["function-warning"],
          ["debug-alerts"]
        ]
      },
      {
        "id": "function-critical",
        "type": "function",
        "z": "flow20",
        "name": "üö® Alerte Critique",
        "func": "// Traitement des alertes critiques\nconst alert = msg.alerts[0];\n\n// Cr√©er un message d'urgence\nmsg.payload = {\n    level: 'CRITICAL',\n    message: `üö® URGENT: ${alert.name}`,\n    details: alert.summary,\n    value: alert.value,\n    timestamp: new Date().toISOString(),\n    action_required: true\n};\n\n// Notification push (simulation)\nmsg.notification = {\n    title: 'üö® Alerte Critique',\n    body: alert.summary,\n    urgency: 'high'\n};\n\nnode.status({fill: 'red', shape: 'dot', text: 'Alerte critique!'});\n\nsetTimeout(() => {\n    node.status({});\n}, 10000);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 280,
        "wires": [["debug-critical"]]
      },
      {
        "id": "function-warning",
        "type": "function",
        "z": "flow20",
        "name": "‚ö†Ô∏è Alerte Warning",
        "func": "// Traitement des alertes d'avertissement\nconst alert = msg.alerts[0];\n\nmsg.payload = {\n    level: 'WARNING',\n    message: `‚ö†Ô∏è Attention: ${alert.name}`,\n    details: alert.summary,\n    value: alert.value,\n    timestamp: new Date().toISOString(),\n    action_required: false\n};\n\nnode.status({fill: 'yellow', shape: 'dot', text: 'Avertissement'});\n\nsetTimeout(() => {\n    node.status({});\n}, 5000);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 320,
        "wires": [["debug-warning"]]
      },
      {
        "id": "debug-alerts",
        "type": "debug",
        "z": "flow20",
        "name": "üìã Debug Alertes",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 880,
        "y": 360,
        "wires": []
      },
      {
        "id": "debug-critical",
        "type": "debug",
        "z": "flow20",
        "name": "üö® Log Critique",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 280,
        "wires": []
      },
      {
        "id": "debug-warning",
        "type": "debug",
        "z": "flow20",
        "name": "‚ö†Ô∏è Log Warning",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 320,
        "wires": []
      },
      {
        "id": "http-in-test",
        "type": "http in",
        "z": "flow20",
        "name": "üß™ Test Value HTTP",
        "url": "/test-value",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 480,
        "wires": [["function-test-value"]]
      },
      {
        "id": "function-test-value",
        "type": "function",
        "z": "flow20",
        "name": "üéØ Test Value Parser",
        "func": "// Parser la valeur de test {value: 10}\nif (!msg.payload || typeof msg.payload.value === 'undefined') {\n    msg.payload = {error: 'Format invalide. Utilisez {\"value\": 10}'};\n    msg.statusCode = 400;\n    return msg;\n}\n\nconst testValue = parseFloat(msg.payload.value);\n\nif (isNaN(testValue)) {\n    msg.payload = {error: 'La valeur doit √™tre un nombre'};\n    msg.statusCode = 400;\n    return msg;\n}\n\n// Cr√©er le payload pour Grafana\nmsg.payload = {\n    value: testValue,\n    test_source: 'node-red-http',\n    timestamp: new Date().toISOString()\n};\n\nmsg.statusCode = 200;\n\nnode.log(`Valeur de test re√ßue: ${testValue}`);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 480,
        "wires": [["grafana-send-test", "http-response-test"]]
      },
      {
        "id": "grafana-send-test",
        "type": "grafana-send",
        "z": "flow20",
        "name": "üìà Grafana Test",
        "grafanaUrl": "http://localhost:3000",
        "apiToken": "glsa_xxxxxxxxxxxxxxxx",
        "datasourceName": "influxdb-uid",
        "measurement": "sensor_data",
        "x": 710,
        "y": 480,
        "wires": [["debug-test-sent"]]
      },
      {
        "id": "http-response-test",
        "type": "http response",
        "z": "flow20",
        "name": "‚úÖ R√©ponse Test",
        "statusCode": "",
        "headers": {},
        "x": 710,
        "y": 520,
        "wires": []
      },
      {
        "id": "debug-test-sent",
        "type": "debug",
        "z": "flow20",
        "name": "üìä Test Envoy√©",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 480,
        "wires": []
      },
      {
        "id": "comment-1",
        "type": "comment",
        "z": "flow20",
        "name": "üìä SC√âNARIO 1: R√©ception donn√©es capteurs ‚Üí Grafana",
        "info": "Ce flux re√ßoit des donn√©es de capteurs m√©t√©o via HTTP POST\net les envoie vers Grafana pour affichage dans le dashboard.\n\nTest avec:\ncurl -X POST http://localhost:1880/sensor-data \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"temperature\": 25.5, \"humidity\": 68.2, \"location\": \"salon\"}'",
        "x": 290,
        "y": 60,
        "wires": []
      },
      {
        "id": "comment-2",
        "type": "comment",
        "z": "flow20",
        "name": "üîî SC√âNARIO 2: Grafana Alertes ‚Üí Node-RED",
        "info": "Ce flux re√ßoit les alertes et notifications depuis Grafana\nvia webhook et les traite selon leur s√©v√©rit√©.\n\nConfiguration Grafana:\n- Contact Point: Webhook\n- URL: http://votre-ip:1880/grafana-webhook\n- Method: POST",
        "x": 280,
        "y": 280,
        "wires": []
      },
      {
        "id": "comment-3",
        "type": "comment",
        "z": "flow20",
        "name": "üß™ SC√âNARIO 3: Test HTTP {value: 10} ‚Üí Grafana",
        "info": "Test simple pour envoyer une valeur vers Grafana.\n\nTest avec:\ncurl -X POST http://localhost:1880/test-value \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"value\": 10}'",
        "x": 280,
        "y": 440,
        "wires": []
      }
    ]
  }
]